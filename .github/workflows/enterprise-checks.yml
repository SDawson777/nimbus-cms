name: Enterprise Checks

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: {}

jobs:
  enterprise-checks:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure pnpm on PATH
        run: |
          npm install -g pnpm@9
          pnpm --version

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      # pnpm is already ensured earlier so caching/setup can rely on it

      - name: Install
        run: pnpm install --frozen-lockfile

      - name: Run types (server)
        run: pnpm run lint:types

      - name: Run client env audit
        run: pnpm audit:client-envs

      - name: Generate license report
        run: pnpm licenses:generate
      - name: Install Playwright browsers
        run: pnpm -w dlx playwright install --with-deps
      - name: Build server and admin
        run: |
          pnpm -C server build
          # Build admin with API base pointing to the server on 8080
          VITE_NIMBUS_API_URL="http://localhost:8080" pnpm -C apps/admin build

      - name: Start server and serve admin from API (background)
        run: |
          # Seed test admin via env vars and write to server/config/admins.json for deterministic E2E
          # If you want to override these defaults in GitHub Actions, add an
          # `env:` mapping in this step from repo secrets/variables.
          export SERVER_JWT_SECRET="test-jwt-secret-xxxxxxxxxxxxxxxxxxxxxxxx"
          # Provide JWT_SECRET expected by server config (some scripts expect JWT_SECRET)
          export JWT_SECRET="$SERVER_JWT_SECRET"
          export E2E_ADMIN_EMAIL="e2e-admin@example.com"
          export E2E_ADMIN_PASSWORD="e2e-password"
          export E2E_ADMIN_SECONDARY_EMAIL="e2e-editor@example.com"
          export E2E_ADMIN_SECONDARY_PASSWORD="e2e-editor-pass"
          export E2E_ADMIN_SECONDARY_ROLE="EDITOR"
          export DATABASE_URL="file:./dev.db"
          export ADMIN_STORE="file"
          export CORS_ORIGIN_ADMIN="http://localhost:8080"
          # Relax global rate limits for CI so SPA asset fan-out won't be blocked by 429s
          export GLOBAL_RATE_LIMIT_MAX=10000
          export GLOBAL_RATE_LIMIT_WINDOW_MS=600000
          # Relax rate limits for CI so E2E won't be blocked by 429s
          export ADMIN_GLOBAL_RATE_LIMIT_MAX=1000
          export ADMIN_GLOBAL_RATE_LIMIT_WINDOW_MS=600000
          export ADMIN_LOGIN_RATE_LIMIT_MAX=1000
          export ADMIN_LOGIN_RATE_LIMIT_WINDOW_MS=600000
          export NODE_ENV=development

          # Write seeded admin into server/config/admins.json so the server uses file-backed admin auth
          pnpm -C server run seed:e2e

          # Copy seeded admins into built runtime path so the compiled server sees them
          mkdir -p server/dist/config
          cp -a server/config/admins.json server/dist/config/admins.json || true

          # Validate the seeded admin exists in the file
          node -e "const fs=require('fs');const p='server/config/admins.json';const e=process.env.E2E_ADMIN_EMAIL||'e2e-admin@example.com';if(!fs.existsSync(p)){console.error('admins.json missing');process.exit(2);}const j=JSON.parse(fs.readFileSync(p,'utf8'));if(!Array.isArray(j.admins)||!j.admins.find(a=>a.email===e)){console.error('Seeded admin not found in '+p);console.error(JSON.stringify(j,null,2));process.exit(2);}console.log('Seeded admin validated');"

          # Start server (it will serve static admin from server/static/admin)
          nohup node server/dist/index.js > server.log 2>&1 &
          echo $! > server.pid

          # Copy built admin into the server static folder so it's served same-origin
          mkdir -p server/static
          cp -a apps/admin/dist/. server/static/

          # Export the Playwright base URL to point at the API server admin path (same-origin)
          echo "E2E_BASE_URL=http://localhost:8080" >> $GITHUB_ENV

          # Persist these environment variables to subsequent workflow steps
          # so Playwright and other steps can access the seeded admin credentials
          # and runtime settings. `GITHUB_ENV` makes them available to later
          # steps in the same job.
          echo "SERVER_JWT_SECRET=${SERVER_JWT_SECRET}" >> $GITHUB_ENV
          echo "JWT_SECRET=${JWT_SECRET}" >> $GITHUB_ENV
          echo "E2E_ADMIN_EMAIL=${E2E_ADMIN_EMAIL}" >> $GITHUB_ENV
          echo "E2E_ADMIN_PASSWORD=${E2E_ADMIN_PASSWORD}" >> $GITHUB_ENV
          echo "E2E_ADMIN_SECONDARY_EMAIL=${E2E_ADMIN_SECONDARY_EMAIL}" >> $GITHUB_ENV
          echo "E2E_ADMIN_SECONDARY_PASSWORD=${E2E_ADMIN_SECONDARY_PASSWORD}" >> $GITHUB_ENV
          echo "E2E_ADMIN_SECONDARY_ROLE=${E2E_ADMIN_SECONDARY_ROLE}" >> $GITHUB_ENV
          echo "DATABASE_URL=${DATABASE_URL}" >> $GITHUB_ENV
          echo "ADMIN_STORE=${ADMIN_STORE}" >> $GITHUB_ENV
          echo "CORS_ORIGIN_ADMIN=${CORS_ORIGIN_ADMIN}" >> $GITHUB_ENV
          echo "GLOBAL_RATE_LIMIT_MAX=${GLOBAL_RATE_LIMIT_MAX}" >> $GITHUB_ENV
          echo "GLOBAL_RATE_LIMIT_WINDOW_MS=${GLOBAL_RATE_LIMIT_WINDOW_MS}" >> $GITHUB_ENV
          echo "E2E_BASE_URL=http://localhost:8080" >> $GITHUB_ENV
          echo "ADMIN_GLOBAL_RATE_LIMIT_MAX=${ADMIN_GLOBAL_RATE_LIMIT_MAX}" >> $GITHUB_ENV
          echo "ADMIN_GLOBAL_RATE_LIMIT_WINDOW_MS=${ADMIN_GLOBAL_RATE_LIMIT_WINDOW_MS}" >> $GITHUB_ENV
          echo "ADMIN_LOGIN_RATE_LIMIT_MAX=${ADMIN_LOGIN_RATE_LIMIT_MAX}" >> $GITHUB_ENV
          echo "ADMIN_LOGIN_RATE_LIMIT_WINDOW_MS=${ADMIN_LOGIN_RATE_LIMIT_WINDOW_MS}" >> $GITHUB_ENV
          echo "NODE_ENV=${NODE_ENV}" >> $GITHUB_ENV

      - name: Wait for services
        run: |
          # Wait up to 2 minutes for both services to become available. If they
          # don't respond in time, dump the server and admin logs to help
          # diagnose the failure and fail the job.
          pnpm -w dlx wait-on --timeout 120000 http://localhost:8080/healthz http://localhost:8080/admin/login || (
            echo "\nERROR: Services did not become ready within timeout. Dumping logs...\n";
            echo "---- server.log (last 200 lines) ----";
            if [ -f server.log ]; then tail -n 200 server.log; else echo "(no server.log)"; fi;
            echo "---- admin dist index.html (head) ----";
            if [ -f apps/admin/dist/index.html ]; then sed -n '1,200p' apps/admin/dist/index.html; else echo "(no apps/admin/dist/index.html)"; fi;
            exit 1
          )

      - name: Preflight admin login readiness
        run: |
          echo "Preflight: waiting for /admin/login to return 200 and index markup"
          for i in $(seq 1 30); do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/admin/login || true)
            HTML=$(curl -s http://localhost:8080/admin/login || true)
            if [ "$STATUS" = "200" ] && (echo "$HTML" | grep -q '<div id="root">' || echo "$HTML" | grep -qi '<html'); then
              echo "Login route is served (status $STATUS) and index markup detected. Proceeding to tests.";
              exit 0
            fi
            echo "Waiting for login route: status=$STATUS, attempt ($i/30)";
            sleep 2
          done
          echo "Preflight failed: /admin/login did not return index markup or status 200 within timeout.";
          # Show what we saved earlier if present
          if [ -f apps/admin/test-ci-output/ci-login.html ]; then head -n 200 apps/admin/test-ci-output/ci-login.html; fi
          exit 1

      - name: Dump admin preview and server logs (debug)
        run: |
            echo "Checking admin preview /login -> status and head"
            # Try to fetch the login page and save it for inspection
            mkdir -p apps/admin/test-ci-output || true
            curl -s -D - http://localhost:8080/admin/login -o apps/admin/test-ci-output/ci-login.html || true
            echo "---- admin login (head) ----"
            head -n 200 apps/admin/test-ci-output/ci-login.html || true
            echo "---- server.log (tail) ----"
            tail -n 200 server.log || true
            echo "---- admin.log (tail) ----"
            tail -n 200 admin.log || true

      - name: Upload CI debug page
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ci-admin-debug
          path: |
            apps/admin/test-ci-output/ci-login.html
            server.log
            admin.log

      - name: Run admin e2e tests (blocking)
        working-directory: apps/admin
        run: pnpm test:e2e

      - name: Run server unit tests
        working-directory: server
        run: pnpm test

      - name: Tear down background services
        if: always()
        run: |
          if [ -f server.pid ]; then kill "$(cat server.pid)" || true; fi
          if [ -f admin.pid ]; then kill "$(cat admin.pid)" || true; fi
          sleep 1

      - name: Restore admins.json backup (if present)
        if: always()
        run: |
          CFG="server/config/admins.json"
          BACKUP=$(ls ${CFG}.bak.* 2>/dev/null | tail -n 1 || true)
          if [ -n "$BACKUP" ]; then
            echo "Restoring $CFG from $BACKUP"
            mv "$BACKUP" "$CFG"
          else
            echo "No admins.json backup found; leaving $CFG as-is"
          fi

      - name: Upload server & admin logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: server-admin-logs
          path: |
            server.log
            admin.log

      - name: Upload Playwright artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-artifacts
          path: |
            apps/admin/playwright-report
            test-results/**
